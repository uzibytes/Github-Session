1. Database Commands
View all databases
show dbs


Create a new or switch databases 
use dbName


View current Database
db


Delete Database 
db.dropDatabase()


2. Collection Commands

Show Collections
show collections

Create a collection named 'comments'
db.createCollection('comments')

Drop a collection named 'comments'
db.comments.drop()


3. Row(Document) Commands



Show all Rows in a Collection 
db.comments.find()

Show all Rows in a Collection (Prettified)
db.comments.find().pretty()

Find the first row matching the object
db.comments.findOne({name: 'Harry'})

Insert One Row
db.comments.insert({
    'name': 'Harry',
    'lang': 'JavaScript',
    'member_since': 5
 })
Insert many Rows
db.comments.insertMany([{
    'name': 'Harry',
    'lang': 'JavaScript',
    'member_since': 5
    }, 
    {'name': 'Rohan',
    'lang': 'Python',
    'member_since': 3
    },
    {'name': 'Lovish',
    'lang': 'Java',
    'member_since': 4
}])


/*Replication
MongoDB provides high availability with replica sets.[29] A replica set consists of two or more copies of the data. Each replica-set member may act in the role of primary or secondary replica at any time. All writes and reads are done on the primary replica by default. Secondary replicas maintain a copy of the data of the primary using built-in replication. When a primary replica fails, the replica set automatically conducts an election process to determine which secondary should become the primary. Secondaries can optionally serve read operations, but that data is only eventually consistent by default.

If the replicated MongoDB deployment only has a single secondary member, a separate daemon called an arbiter must be added to the set. It has a single responsibility, which is to resolve the election of the new primary.[30] As a consequence, an idealized distributed MongoDB deployment requires at least three separate servers, even in the case of just one primary and one secondary.[30]*/
